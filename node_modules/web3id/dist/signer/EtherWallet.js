"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EtherWallet = void 0;
const ethers_1 = require("ethers");
const lodash_1 = __importDefault(require("lodash"));
/**
 * 	@class
 */
class EtherWallet {
    /**
     *	@param wallet	{any} wallet object
     *	@returns {boolean}
     */
    static isValidWalletFactoryData(wallet) {
        return lodash_1.default.isObject(wallet) &&
            lodash_1.default.has(wallet, 'isHD') &&
            lodash_1.default.has(wallet, 'mnemonic') &&
            lodash_1.default.has(wallet, 'password') &&
            lodash_1.default.has(wallet, 'address') &&
            lodash_1.default.has(wallet, 'publicKey') &&
            lodash_1.default.has(wallet, 'privateKey') &&
            lodash_1.default.has(wallet, 'index') &&
            lodash_1.default.has(wallet, 'path');
    }
    // public static createDerivedWalletObject( walletItem : TWalletBaseItem, derivePath ?: string )
    // {
    // 	const walletObject = this.createWalletObject( walletItem );
    // 	if ( walletObject )
    // 	{
    // 		const derivedWalletObject = walletObject.derivePath( derivePath );
    // 	}
    // }
    /**
     *	@param walletItem	{TWalletBaseItem}
     *	@returns { ethers.HDNodeWallet | ethers.Wallet | null }
     */
    static createWalletObject(walletItem) {
        if (null === walletItem) {
            throw new Error(`invalid walletItem`);
        }
        let walletObject = null;
        if (walletItem.mnemonic &&
            ethers_1.ethers.Mnemonic.isValidMnemonic(walletItem.mnemonic)) {
            const mnemonicObj = ethers_1.ethers.Mnemonic.fromPhrase(walletItem.mnemonic);
            if (!mnemonicObj || !mnemonicObj.phrase) {
                throw new Error(`failed to create mnemonic object`);
            }
            walletObject = ethers_1.ethers.HDNodeWallet.fromMnemonic(mnemonicObj);
        }
        else if (lodash_1.default.isString(walletItem.privateKey) && !lodash_1.default.isEmpty(walletItem.privateKey)) {
            let privateKeyObj;
            try {
                if (!walletItem.privateKey.startsWith('0x')) {
                    walletItem.privateKey = '0x' + walletItem.privateKey;
                }
                privateKeyObj = new ethers_1.ethers.SigningKey(walletItem.privateKey);
            }
            catch (error) {
                throw new Error('invalid format of private key');
            }
            walletObject = new ethers_1.ethers.Wallet(privateKeyObj);
        }
        return walletObject;
    }
    /**
     * 	Create a wallet from a mnemonic phrase.
     *	@param mnemonic	- string
     *	@returns {TWalletBaseItem}
     */
    static createWalletFromMnemonic(mnemonic) {
        var _a;
        //
        //	TODO
        //	should add parameter password
        //
        let mnemonicObj;
        if (!mnemonic) {
            //	If the user does not specify a mnemonic phrase,
            //	a random one will be created.
            mnemonicObj = ethers_1.ethers.Wallet.createRandom().mnemonic;
            //	console.log(mnemonicObj.phrase);
        }
        else {
            if (!ethers_1.ethers.Mnemonic.isValidMnemonic(mnemonic)) {
                throw new Error('invalid mnemonic');
            }
            mnemonicObj = ethers_1.ethers.Mnemonic.fromPhrase(mnemonic);
            // console.log(mnemonicObj.phrase);
        }
        if (!mnemonicObj || !mnemonicObj.phrase) {
            throw new Error(`failed to create mnemonic object`);
        }
        const walletObj = ethers_1.ethers.HDNodeWallet.fromMnemonic(mnemonicObj);
        return this.decorateResult({
            isHD: true,
            mnemonic: (_a = walletObj === null || walletObj === void 0 ? void 0 : walletObj.mnemonic) === null || _a === void 0 ? void 0 : _a.phrase,
            password: '',
            address: walletObj === null || walletObj === void 0 ? void 0 : walletObj.address,
            publicKey: walletObj === null || walletObj === void 0 ? void 0 : walletObj.publicKey,
            privateKey: walletObj === null || walletObj === void 0 ? void 0 : walletObj.privateKey,
            index: walletObj === null || walletObj === void 0 ? void 0 : walletObj.index,
            path: walletObj === null || walletObj === void 0 ? void 0 : walletObj.path
        });
    }
    /**
     * 	Returns the wallet details for the JSON Keystore Wallet json using {password}.
     * 	https://docs.ethers.org/v6/api/wallet/
     *	https://docs.ethers.org/v6/api/wallet/#KeystoreAccount
     *	@param keystoreJson	{string} Wallet keystore JSON string
     *	@param password		{string} decrypt keystoreJson using {password}
     *	@returns {Promise<TWalletBaseItem>}
     */
    static createWalletFromKeystore(keystoreJson, password = '') {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!(0, ethers_1.isKeystoreJson)(keystoreJson)) {
                    return reject(`invalid keystoreJson`);
                }
                const progressCallback = (_percent) => {
                    //	A callback during long-running operations to update any UI or
                    //	provide programmatic access to the progress.
                    //
                    // 	The percent is a value between 0 and 1.
                };
                //	Returns the account details for the JSON Keystore Wallet json using password.
                const keystoreAccount = yield (0, ethers_1.decryptKeystoreJson)(keystoreJson, password, progressCallback);
                if (!keystoreAccount) {
                    return reject(`error in decryptKeystoreJson`);
                }
                const wallet = this.createWalletFromPrivateKey(keystoreAccount.privateKey);
                if (!this.isValidWalletFactoryData(wallet)) {
                    return reject(`error in createWalletFromPrivateKey`);
                }
                resolve(wallet);
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * 	Resolved to the JSON Keystore Wallet for {wallet} encrypted with {password}.
     *	@param wallet	{TWalletBaseItem}
     *	@param password	{string}		encrypt {wallet} with {password}
     *	@returns {Promise<string>}
     */
    static getKeystoreOfWallet(wallet, password = '') {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.isValidWalletFactoryData(wallet)) {
                    return reject(`invalid wallet`);
                }
                if (!lodash_1.default.isString(wallet.address) || lodash_1.default.isEmpty(wallet.address)) {
                    return reject(`invalid wallet.address`);
                }
                if (!lodash_1.default.isString(wallet.privateKey) || lodash_1.default.isEmpty(wallet.privateKey)) {
                    return reject(`invalid wallet.privateKey`);
                }
                const account = {
                    address: wallet.address,
                    mnemonic: undefined,
                    privateKey: wallet.privateKey,
                };
                const encryptOptions = {
                    progressCallback: (_percent) => {
                        //	A callback during long-running operations to update any UI or
                        //	provide programmatic access to the progress.
                        //
                        // 	The percent is a value between 0 and 1.
                    }
                };
                //	Resolved to the JSON Keystore Wallet for account encrypted with password.
                const keystore = yield (0, ethers_1.encryptKeystoreJson)(account, password, encryptOptions);
                resolve(keystore);
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * 	https://iancoleman.io/bip39/
     * 	扩展私钥不是钱包的私钥，是助记词
     * 	m/44'/60'/0'/0
     * 	Derivation Path  BIP44
     *
     * 	Create a wallet from an extended private key.
     *	supported BIP32 Root Key | Account Extended Private Key | BIP32 Extended Private Key
     *	@param {*} extendedKey	- BIP32 Extended Private Key
     *	@returns {TWalletBaseItem}
     */
    static createWalletFromExtendedKey(extendedKey) {
        if (!extendedKey) {
            throw new Error('no extended private key specified.');
        }
        const walletObj = ethers_1.ethers.HDNodeWallet.fromExtendedKey(extendedKey);
        let wallet = {};
        wallet.isHD = true;
        wallet.mnemonic = '';
        wallet.password = '';
        let deriveWallet;
        switch (walletObj.depth) {
            case 0:
                //	Mnemonic
                //	给出衍生路径，补齐五层衍生路径为 "m/44'/60'/0'/0/0"
                deriveWallet = walletObj.derivePath(ethers_1.ethers.defaultPath);
                wallet = Object.assign(Object.assign({}, wallet), { address: deriveWallet.address, publicKey: deriveWallet.publicKey, 
                    // privateKey : deriveWallet.privateKey,
                    index: deriveWallet.index, path: ethers_1.ethers.defaultPath });
                break;
            case 3:
                //	m/44'/60'/0'/0
                //	给出衍生路径，补齐五层衍生路径为 "m/44'/60'/0'/0/0"，补的就是最后的 "/0/0"
                deriveWallet = walletObj.derivePath('m/0/0');
                wallet = Object.assign(Object.assign({}, wallet), { address: deriveWallet.address, publicKey: deriveWallet.publicKey, 
                    // privateKey : deriveWallet.privateKey,
                    index: deriveWallet.index, path: ethers_1.ethers.defaultPath });
                break;
            case 4:
                //	给出衍生路径，补齐五层衍生路径为 "m/44'/60'/0'/0/0"，补的就是最后的 "/0"
                deriveWallet = walletObj.derivePath('m/0');
                wallet = Object.assign(Object.assign({}, wallet), { address: deriveWallet.address, publicKey: deriveWallet.publicKey, 
                    // privateKey : deriveWallet.privateKey,
                    index: deriveWallet.index, path: ethers_1.ethers.defaultPath });
                break;
            default:
                throw new Error('Unsupported type of extended private key');
        }
        return this.decorateResult(wallet);
    }
    /**
     *	Create a wallet from a wallet private key
     *	@param {*} privateKey
     *	@returns {TWalletBaseItem}
     */
    static createWalletFromPrivateKey(privateKey = null) {
        if (!privateKey) {
            //	If the private key does not exist,
            //	create a random private key.
            privateKey = ethers_1.ethers.Wallet.createRandom().privateKey;
        }
        let privateKeyObj;
        try {
            if (typeof privateKey == 'string' && !privateKey.startsWith('0x')) {
                privateKey = '0x' + privateKey;
            }
            privateKeyObj = new ethers_1.ethers.SigningKey(privateKey);
        }
        catch (error) {
            throw new Error('invalid format of private key');
        }
        //
        //	walletObj output:
        //	{
        //		"provider":null,
        //		"address":"0x7b65aBA47A1575879A1f28734e1386bf47D01700"
        //	}
        //
        const walletObj = new ethers_1.ethers.Wallet(privateKeyObj);
        //console.log( `🧲`, JSON.stringify( walletObj ) );
        return this.decorateResult({
            isHD: false,
            mnemonic: '',
            password: '',
            address: walletObj.address,
            publicKey: ethers_1.ethers.SigningKey.computePublicKey(walletObj.privateKey, true),
            privateKey: walletObj.privateKey,
            index: 0, //	walletObj.index,
            path: null, //	walletObj.path
        });
    }
    /**
     *	Create a watch wallet from a wallet address
     *	@param {*} address
     *	@returns {TWalletBaseItem}
     */
    static createWalletFromAddress(address) {
        if (!this.isValidAddress(address)) {
            throw new Error('invalid address');
        }
        return this.decorateResult({
            isHD: false,
            mnemonic: '',
            password: '',
            address: address,
            publicKey: '',
            privateKey: '',
            index: 0, //	walletObj.index,
            path: null, //	walletObj.path
        });
    }
    /**
     * 	@param address	{string} wallet address
     * 	@returns {TWalletBaseItem}
     */
    static createWatchWallet(address) {
        return this.createWalletFromAddress(address);
    }
    /**
     *	@param address	{string} wallet address
     *	@return {boolean}
     */
    static isValidAddress(address) {
        return lodash_1.default.isString(address) && !lodash_1.default.isEmpty(address) && (0, ethers_1.isAddress)(address);
    }
    /**
     *	@param privateKey	{any}
     *	@returns {boolean}
     */
    static isValidPrivateKey(privateKey) {
        return lodash_1.default.isString(privateKey) && !lodash_1.default.isEmpty(privateKey) && (0, ethers_1.isHexString)(privateKey, 32);
    }
    /**
     *	@param publicKey	{any}
     *	@returns {boolean}
     */
    static isValidPublicKey(publicKey) {
        return lodash_1.default.isString(publicKey) && !lodash_1.default.isEmpty(publicKey) && (0, ethers_1.isHexString)(publicKey, 33);
    }
    /**
     *	@param input	{any}
     *	@returns {boolean}
     */
    static isValidLowercaseHex(input) {
        const hexPattern = /^(0x)?[0-9a-f]+$/;
        return lodash_1.default.isString(input) && !lodash_1.default.isEmpty(input) && hexPattern.test(input);
    }
    /**
     *	Generate a new address for the specified wallet
     *	@param wallet	{any}
     *	@returns {TWalletBaseItem}
     */
    static createNewAddress(wallet) {
        var _a;
        if (!wallet) {
            throw new Error('wallet not specified');
        }
        const mnemonicObj = ethers_1.ethers.Mnemonic.fromPhrase(wallet.mnemonic);
        const nextPath = ethers_1.ethers.getIndexedAccountPath(wallet.index + 1);
        const walletObj = ethers_1.ethers.HDNodeWallet.fromMnemonic(mnemonicObj, nextPath);
        return this.decorateResult({
            isHD: true,
            mnemonic: (_a = walletObj === null || walletObj === void 0 ? void 0 : walletObj.mnemonic) === null || _a === void 0 ? void 0 : _a.phrase,
            password: '',
            address: walletObj.address,
            publicKey: walletObj.publicKey,
            privateKey: walletObj.privateKey,
            index: walletObj.index,
            path: walletObj.path
        });
    }
    /**
     *	@param walletItem	{TWalletBaseItem}
     *	@returns {TWalletBaseItem}
     *	@private
     */
    static decorateResult(walletItem) {
        if (!walletItem) {
            throw new Error(`invalid walletItem`);
        }
        return Object.assign(Object.assign({}, walletItem), { address: lodash_1.default.isString(walletItem.address) ? walletItem.address.trim().toLowerCase() : walletItem.address, publicKey: lodash_1.default.isString(walletItem.publicKey) ? walletItem.publicKey.trim().toLowerCase() : walletItem.publicKey, privateKey: lodash_1.default.isString(walletItem.privateKey) ? walletItem.privateKey.trim().toLowerCase() : walletItem.privateKey });
    }
}
exports.EtherWallet = EtherWallet;
//# sourceMappingURL=EtherWallet.js.map