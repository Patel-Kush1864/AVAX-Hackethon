"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3Encoder = void 0;
const lodash_1 = __importDefault(require("lodash"));
/**
 * 	@class Web3Encoder
 */
class Web3Encoder {
    /**
     *	@param obj		{Record<string, any>}
     *	@param exceptedKeys	{Array<string>}
     *	@returns {Promise<string>}
     */
    static encode(obj, exceptedKeys) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!obj) {
                    return reject(`invalid obj`);
                }
                let keysToRemove = ['sig', 'hash', 'createdAt', 'updatedAt'];
                if (Array.isArray(exceptedKeys) && exceptedKeys.length > 0) {
                    keysToRemove = Array.from(new Set([...keysToRemove, ...exceptedKeys]));
                }
                const cleanedUpObj = this.removeObjectKeys(obj, keysToRemove);
                const sortedObj = this.sortObjectByKeys(cleanedUpObj);
                const encodedMessage = JSON.stringify(sortedObj);
                resolve(encodedMessage);
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     *	@param encodedMessage	{string}
     *	@returns {Promise<Record<string, any>>}
     */
    static decode(encodedMessage) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                resolve(JSON.parse(encodedMessage));
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * 	determine whether the key of an object is of string type
     *	@param obj
     *	@param key
     *	@returns {boolean}
     */
    static isStringKey(obj, key) {
        return key in obj;
    }
    /**
     *	@param obj		{ Record<string, any> }
     *	@param keysToRemove	{ Array<string> }
     *	@returns { Record<string, any> }
     */
    static removeObjectKeys(obj, keysToRemove) {
        if (!lodash_1.default.isObject(obj) || null === obj) {
            return obj;
        }
        if (!Array.isArray(keysToRemove) || 0 === keysToRemove.length) {
            return obj;
        }
        return Object.fromEntries(Object.entries(obj).filter(([key]) => !keysToRemove.includes(key)));
    }
    /**
     *	@param obj		{Record<string, any>}
     *	@param reservedKeys	{Array<string>}
     *	@returns {Record<string, any>}
     */
    static reserveObjectKeys(obj, reservedKeys) {
        if (!lodash_1.default.isObject(obj) || null === obj) {
            return obj;
        }
        if (!Array.isArray(reservedKeys) || 0 === reservedKeys.length) {
            return obj;
        }
        return Object.fromEntries(Object.entries(obj).filter(([key]) => reservedKeys.includes(key)));
    }
    /**
     *	@param obj	{*}
     *	@returns {*}
     */
    static sortObjectByKeys(obj) {
        try {
            if ('object' !== typeof obj || null === obj) {
                return obj;
            }
            if (Array.isArray(obj)) {
                return obj.map((this.sortObjectByKeys));
            }
            const stringKeysObj = obj;
            const sortedObject = {};
            //	Get the keys and sort them alphabetically
            const keys = Object.keys(stringKeysObj).sort();
            for (const key of keys) {
                if (!this.isStringKey(stringKeysObj, key)) {
                    continue;
                }
                //	recursively sort nested objects
                sortedObject[key] = this.sortObjectByKeys(stringKeysObj[key]);
            }
            return sortedObject;
        }
        catch (err) {
            return obj;
        }
    }
}
exports.Web3Encoder = Web3Encoder;
//# sourceMappingURL=Web3Encoder.js.map