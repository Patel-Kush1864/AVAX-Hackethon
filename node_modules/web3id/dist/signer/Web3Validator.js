"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3Validator = void 0;
const ethers_1 = require("ethers");
const Web3Encoder_1 = require("./Web3Encoder");
const lodash_1 = __importDefault(require("lodash"));
/**
 * 	@class Web3Validator
 */
class Web3Validator {
    /**
     *	@param signerWalletAddress	{string}
     *	@param obj			{any}
     *	@param sig			{string}
     *	@param exceptedKeys		{Array<string>}
     *	@returns {boolean}
     */
    static validateObject(signerWalletAddress, obj, sig, exceptedKeys) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!lodash_1.default.isString(signerWalletAddress) || lodash_1.default.isEmpty(signerWalletAddress)) {
                    return reject(`invalid signerWalletAddress`);
                }
                if (!lodash_1.default.isObject(obj) || null === obj) {
                    return reject(`invalid obj`);
                }
                if (!lodash_1.default.isString(sig) || lodash_1.default.isEmpty(sig)) {
                    return reject(`invalid sig`);
                }
                //	...
                const dataToSign = yield Web3Encoder_1.Web3Encoder.encode(obj, exceptedKeys);
                const isSignatureValid = this.validateMessage(signerWalletAddress, dataToSign, sig);
                resolve(isSignatureValid);
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     *	@param signerWalletAddress	{string}
     *	@param message			{Uint8Array | string}
     *	@param sig			{string}
     *	@returns {boolean}
     */
    static validateMessage(signerWalletAddress, message, sig) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!lodash_1.default.isString(signerWalletAddress) || lodash_1.default.isEmpty(signerWalletAddress)) {
                    return reject(`invalid signerWalletAddress`);
                }
                if (!message) {
                    return reject(`invalid message`);
                }
                if (!lodash_1.default.isString(sig) || lodash_1.default.isEmpty(sig)) {
                    return reject(`invalid sig`);
                }
                //	ether verify
                const verifyResult = (0, ethers_1.verifyMessage)(message, sig);
                const isSignatureValid = verifyResult.trim().toLowerCase() === signerWalletAddress.trim().toLowerCase();
                // console.log( `signerWalletAddress : `, signerWalletAddress );
                // console.log( `message : `, message );
                // console.log( `sig : `, sig );
                // console.log( `verifyResult : `, verifyResult );
                // console.log( `isSignatureValid : `, isSignatureValid );
                resolve(isSignatureValid);
            }
            catch (err) {
                reject(err);
            }
        }));
    }
}
exports.Web3Validator = Web3Validator;
//# sourceMappingURL=Web3Validator.js.map